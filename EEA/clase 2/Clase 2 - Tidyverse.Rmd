---
title: "Clase 2. Tidyverse y Ggplot"
author: "Juan Barriola y Sofía Perini"
date: "12 de Septiembre de 2020"
output: 
  html_notebook: 
    toc: true
    toc_float: true
    depth: 2
---

# [Tidyverse](https://www.tidyverse.org/)         

Este paquete agrupa una serie de paquetes que tienen una misma lógica en su diseño y por ende funcionan en armonía. Primero vamos a ver algunos de los principales comandos y luego vamos a ver algunos ejemplos de cómo podemos usar las funciones de este paquete. 

Entre ellos usaremos principalmente __ggplot__ para realizar gráficos, y __dplyr__ y __tidyr__ para realizar transformaciones sobre nuestro set de datos.

A continuación cargamos la librería a nuestro ambiente. Para ello debe estar previamente instalada en nuestra pc o se instala con ```install.packages()```.

```{r,eval=FALSE, echo=F}
library(tidyverse)
```

```{r message=FALSE, warning=FALSE}
library(dplyr)
library(tidyr)
library(ggplot2) # para graficar
library(lubridate) # para trabajar con fechas
library(stringr) # para trabajar con strings
```

```

Para mostrar el funcionamiento básico del tidyverse retomaremos el ejemplo de la Clase 1, con lo cual volvemos a crear el set de datos del [Indice de salarios](https://www.indec.gob.ar/indec/web/Nivel4-Tema-4-31-61) del INDEC.

```{r, warning=FALSE}

INDICE  <- c( 286.4,	262.1,	248.5,
              285.7,	263.5,	250.2,
              285.1,	264.9,	249.0 )


FECHA  <-  c("Mar-20", "Mar-20", "Mar-20",
             "Abr-20", "Abr-20", "Abr-20",
             "May-20", "May-20", "May-20")

GRUPO  <-  c("Privado_Registrado","Público","Privado_No_Registrado",
             "Privado_Registrado","Público","Privado_No_Registrado",
             "Privado_Registrado","Público","Privado_No_Registrado")

Datos <- data.frame(INDICE, FECHA, GRUPO)
Datos

```

## Dplyr

El caracter principal para utilizar este paquete es ```%>%``` , _pipe_ (de tubería).

Los ```%>%``` toman el set de datos a su izquierda, y los transforman mediante los comandos a su derecha, en los cuales los elementos de la izquierda están implícitos. En otros términos.

$f(x,y)$ es equivalente a $x$ %>% $f(.,y)$ 

Veamos las principales funciones que pueden utilizarse con la lógica de este paquete:

### Glimpse

Permite ver la estructura de la tabla. Nos muestra: 

* número de filas
* número de columnas
* nombre de las columnas
* tipo de dato de cada columna
* las primeras observaciones de la tabla

```{r}
glimpse(Datos)
```


### filter

Permite filtrar la tabla acorde al cumplimiento de condiciones lógicas
 
```{r}
Datos %>% 
  filter(INDICE > 250 , GRUPO == "Privado_Registrado")
```

Nótese que en este caso al separar con una (coma) `,` las condiciones se exige el cumplimiento de ambas. En caso de desear que se cumpla una sola condición debe utilizarse el caracter `|` (una condición "o" la otra).

```{r}
Datos %>% 
  filter(INDICE > 250 | GRUPO == "Privado_Registrado")
```

### rename

Permite renombrar una columna de la tabla. Funciona de la siguiente manera: 
 ```Data %>% rename( nuevo_nombre = viejo_nombre )``` 
 
```{r}
Datos %>% 
  rename(Periodo = FECHA)
```

Nótese que a diferencia del ejemplo de la función __filter__ donde utilizábamos __==__ para comprobar una condición lógica, en este caso se utiliza sólo un __=__ ya que lo estamos haciendo es _asignar_ un nombre.

### mutate

Permite agregar una nueva variable a la tabla (especificando el nombre que tomará esta), que puede ser el resultado de operaciones sobre otras variables de la misma tabla.       

> Ojo! En caso de especificar el nombre de una columna existente, el resultado de la operación realizada "sobrescribirá" la información de la columna con dicho nombre. 

```{r}
Datos <- Datos %>% 
  mutate(Doble = INDICE * 2)
Datos
```

### case_when

Permite definir una variable, la cual toma un valor particular para cada condición establecida. Los valores asignados deben ser siempre del mismo tipo (numérico, caracter, lógico, etc.).

En caso de no cumplir ninguna de las condiciones establecidas la variable tomara valor __NA__

La sintaxis de la función es  ```case_when( _condicion lógica1_ __~__ _valor asignado1_, _condicion lógica2_ __~__ _valor asignado2_) ```.

```{r}
Datos <- Datos %>% 
  mutate(Caso_cuando = case_when(GRUPO == "Privado_Registrado" ~ INDICE * 2,
                                 GRUPO == "Público"            ~ INDICE * 3))
Datos
```

Una forma de manejar la asignación de valores faltantes es crear una "condición" que sea igual a TRUE. Esto funciona como la parte de **else** de una estructura condicional y la sintaxis es ```case_when(_condicion lógica1_ __~__ _valor asignado1_, _TRUE_ __~__ _valor asignado en caso de no cumplirse la/s condicion/es previas_)```.

```{r}
Datos %>% 
  mutate(Caso_cuando = case_when(GRUPO == "Privado_Registrado" ~ INDICE * 2,
                                 GRUPO == "Público"            ~ INDICE * 3,
                                 TRUE ~ 1000)) 
```

### select

Permite especificar la serie de columnas que se desea conservar de un DataFrame. También pueden especificarse las columnas que se desean descartar (agregándoles un _-_). Muy útil para agilizar el trabajo en bases de datos de gran tamaño.

Así como con la función ```filter()``` se filtran filas de interés, en este caso, la función ```select()``` permite seleccionar columnas de interés, reduciendo la dimensionalidad de la base con la cual trabajar.

```{r}
Datos2 <- Datos %>% 
  select(INDICE, FECHA, GRUPO)
Datos2
# o lo que es igual
Datos <- Datos %>% 
  select(-c(Doble, Caso_cuando))
Datos
```

### arrange

Permite ordenar la tabla por los valores de determinada/s variable/s. Es útil cuando luego deben hacerse otras operaciones que requieran del ordenamiento de la tabla. 

Por default ordena en forma ascendente, si queremos que alguna variable quede ordenada en forma descendente hay que usar ```desc()```. 

```{r}
Datos <- Datos %>% 
  arrange(GRUPO, INDICE)
Datos
# o en forma descendente
Datos <- Datos %>% 
  arrange(GRUPO, desc(INDICE))
Datos

```

### summarise

Crea una nueva tabla que resuma la información original. Para ello, definimos las variables de resumen y las formas de agregación.

```{r}
# por ejemplo calculamos la media del INDICE
Datos %>% 
  summarise(Indprom = mean(INDICE))
```

### group_by

Esta función permite realizar operaciones de forma agrupada. Lo que hace la función es "separar" a la tabla según los valores de la variable indicada y realizar las operaciones que se especifican a continuación, de manera independiente para cada una de las "subtablas". 

En nuestro ejemplo, sería útil para calcular el promedio de los indices por _Fecha_. 

```{r}
Datos %>% 
  group_by(FECHA) %>%
  summarise(Indprom = mean(INDICE))
```

## Joins

Otra implementación muy importante del paquete dplyr son las funciones para unir tablas (joins)

![Fuente: http://rstudio-pubs-static.s3.amazonaws.com/227171_618ebdce0b9d44f3af65700e833593db.html](joins.png){width=500}        

### left_join

Veamos un ejemplo de la función __left_join__ (una de las más utilizadas en la práctica). Para ello, es necesario tener dos tablas y una columna que será la que servirá para unir ambas. 

Para ello crearemos previamente un Dataframe que contenga un Ponderador para cada uno de los Grupos del Dataframe _Datos_. Aprovecharemos el ejemplo para introducir la función __weigthed.mean__, y así calcular un Indice Ponderado.

```{r}
# creamos un dataframe de ponderadores con la columna GRUPO igual al dataset original
Ponderadores <- data.frame(GRUPO = c("Privado_Registrado", "Público", "Privado_No_Registrado"), PONDERADOR = c(50.16,29.91,19.93))
# hacemos el join con el dataframe Datos 
Datos_join <- Datos %>% 
# especificamos la variable que será utilizada para unir ambas tablas con "by"
  left_join(., Ponderadores, by = "GRUPO")
Datos_join
# agrupamos para calcular el indice ponderado
Datos_Indice_Gral <- Datos_join %>% 
  group_by(FECHA) %>% 
  summarise(Indice_Gral = weighted.mean(INDICE, w = PONDERADOR))
Datos_Indice_Gral
```

## Tidyr

El paquete tidyr esta pensado para facilitar el emprolijamiento de los datos.

__Gather__ es una función que nos permite pasar los datos de forma horizontal a una forma vertical. 

__spread__ es una función que nos permite pasar los datos de forma vertical a una forma horizontal.

![Fuente: http://www.gis-blog.com/data-management-with-r-tidyr-part-1/](spreadVSgather.png)

```{r}
# Utilzamos un conjunto de datos que viene con la librería datasets
library(datasets)
data(iris)
iris <- iris %>% 
  mutate(id = 1:nrow(.)) %>% # le agrego un ID
  select(id, everything()) # lo acomodo para que el id este primero. 
iris
```

### Gather 

```{r}
iris_vertical <- iris %>% 
  gather(., # el . llama a lo que esta atras del %>% 
         key = Variables, # la llave es la columna que agrupará variables 
         value = Valores, # columna de valores
         2:5) # le indico que columnas juntar
iris_vertical
```

### Spread

Podemos deshacer el __gather__ con un __Spread__

```{r}
iris_horizontal <- iris_vertical %>%
  spread(. ,
         # la llave es la variable que va a dar los nombres de columna
         key   = Variables, 
         value = Valores) # los valores con que se llenan las celdas
iris_horizontal
```

## Lubridate

El paquete lubridate está pensado para trabajar con los datos tipo fecha(date) o fecha-hora(datetime) para cambiarles el formato, realizar operaciones y extraer información.

### Cambio de formato

Existe una gran cantidad de funciones para realizar esto. La idea general es poder llevar los objetos *datetime* a un formato común compuesto de los elementos: año, mes, día, hora, minuto y segundo (también se puede setear el huso horario).

```{r}
fecha  <- "04/12/92 17:35:16"
fecha
class(fecha)
```

Con la función ```dmy_hms()``` podemos convertir este string a una fecha: estamos indicando que el formato de la fecha es día(d), mes(m), año(y), hora(h), minuto(m) y segundo(s).

```{r}
fecha  <- dmy_hms(fecha)
fecha
class(fecha)
```

Muchas funciones de lubridate operan con esta misma lógica.

Otra función para realizar un cambio de formato es *parse_date_time*. Permite construir objetos *datetime* a partir de datos más complejos, como por ejemplo cuando aparece el nombre del mes y el año.

En el parámetro *x* pasamos el dato de la fecha y en el parámetro *orders* especificamos el orden en el cual se encuentra la información de la fecha, por ejemplo, mes y año (my).

```{r}
fecha2  <- "Dec-92"
fecha2 <- parse_date_time(fecha2, orders = 'my')
fecha2
```

### Extracción de información

Existen muchas funciones muy sencillas para extraer información de un objeto datetime. Algunas son:

```{r}
year(fecha) # Obtener el año
month(fecha) # Obtener el mes
day(fecha) # Obtener el día
wday(fecha, label = TRUE) # Obtener el nombre del día
hour(fecha) # Obtener la hora
```

### Operaciones

Podemos sumar o restarle cualquier período de tiempo a un objeto datetime.

```{r}
# Sumo dos días 
fecha + days(2)
# Resto 1 semana y dos horas
fecha - (weeks(1) + hours(2))
```

## Stringr: manejo de strings

Vamos a usar un paquete muy útil para manejar variables de tipo string, es decir, variables de texto, llamado ```stringr()```. Este paquete cuenta con una cheat sheet que pueden consultar siguiendo este link.

### str_length

Con la función ```str_length()``` podemos ver el largo de un string.

```{r}
string1 <- "abcdefghi"
str_length(string1)
```

> Ojo que cuenta los espacios en blanco como un caracter!

```{r}
string2 <- "abcd efghi"
str_length(string2)
str_sub
```

La función ```str_sub()``` nos permite extraer los caracteres que se encuentran entre determinadas posiciones. Tiene tres argumentos: el **string**, el orden del caracter **a partir** del cual tiene que empezar a extraer y el orden del caracter **hasta** el cual tiene que extraer.

```{r}
#quiero el tercer caracter
str_sub(string1,3,3)
#quiero el cuarto y quinto caracter
str_sub(string1,4,5)
```

Puedo pasarle la posición de los caracteres con un menos para indicar que quiero que cuente de atrás para adelante. Por ejemplo, si quiero que traiga el anteúltimo caracter llamo a la posición como -2.

```{r}
#quiero la última y anteúltima posición
str_sub(string1,-2,-1)
```

Otro uso que le podemos dar a este comando es el de reemplazar elementos. Supongamos que quiero reemplazar la última letra por una z.

```{r}
str_sub(string1,-1,-1) <- "z"
string1
```

### Manejo de espacios en blanco

Es frecuente que aparezcan datos mal cargados o con errores de tipeo que tienen espacios donde no debería haberlos. La función ```str_trim()``` permite que nos deshagamos de los espacios en blanco a izquierda, derecha o ambos lados de nuestro string.

```{r}
string3 <- c("  acelga   ", "brocoli   ",  "   choclo")
#Veamos el string
string3
```

Quitamos los espacios en blanco a ambos lados con el argumento ```side=‘both’```

```{r}
str_trim(string3, side = 'both')
```

Quitamos los espacios en blanco del lado izquierdo con el argumento ```side=‘left’```

```{r}
str_trim(string3, "left")
```

### Mayúsculas y minúsculas

Existen varias funciones para manipular las mayusculas/minúsculas de nuestros strings. A modo de sugerencia, siempre es convientiente manejarse con todos los caracteres en minúscula o en mayúscula. Esto ayuda a normalizar la información para armar mejor grupos, joinear tablas, etc.

```{r}
string4 <- "No me gusta el frio"
string4
#llevo todo a minúsculas
str_to_lower(string4)
#llevo todo a mayúsculas
str_to_upper(string4)
#llevo a mayúscula la primer letra de cada palabra
str_to_title(string4)
```

### str_split

La función ```str_split()``` nos permite partir un string de acuerdo a algún separador/patron (pattern) que definamos.

```{r}
#quiero separar todas las letras de mi string
string1_separado <- str_split(string1,pattern = "")
string1_separado
```

Notemos que esta funcion nos devuelve una lista

```{r}
class(string1_separado)
# Si queremos acceder al primer elemento de la lista
string1_separado[[1]][1]
```

Definimos un nuevo string

```{r}
string5 <- "ab-cd-ef"
string5
```

Lo separamos por el guion

```{r}
str_split(string5, pattern = "-")
```

### Reemplazar elementos de strings

La función base `gsub()` nos permite reemplazar parte del string por otra cosa. Las funciones `str_replace()` y `str_replace_all()` de stringr nos permiten hacer lo mismo.

`str_replace` solo reemplaza la primera ocurrencia del patron mientras que `str_replace_all()` reemplaza todas las ocurrencias


```{r}
string6 <- "todos los caballos blancos"
string6
#le sacamos los espacios
gsub(pattern = " ", replacement = "", x = string6)
#lo llevamos a lenguaje inclusivo
gsub(pattern = "os", replacement = "xs", x = string6)
```

Con stringr

```{r}
# Reemplazamos la primera ocurrencia
str_replace(string = string6, pattern = "os", replacement = "xs")
# Reemplazamos todas las ocurrencias
str_replace_all(string = string6, pattern = "os", replacement = "xs")
```

### Detectar patrones en strings

La función `grepl()` nos permite encontrar expresiones dentro de nuestros strings. Nos reporta VERDADERO o FALSO de acuerdo a si encuentra la expresión que estamos buscando.

La funcion `str_detect()` de `stringr` permite hacer lo mismo.

```{r}
string7 <-c("caño", "baño", "ladrillo")
string7
grepl(pattern = "ñ",x = string7)
str_detect(pattern = "ñ", string = string7)
```

## Ejemplo práctico

Vamos a ver un ejemplo a partir de una base pública que nos trae información sobre ataques de tiburones en el mundo en distintos momentos. Cada fila corresponde a un ataque.

```{r}
tiburones <- read.csv("https://raw.githubusercontent.com/dmuba/dmuba.github.io/3005a7a5e8c9db5c188ca22a7b9269c94db8ced7/Practicos/TPs%20Entregables/TP02/Shark_Attack_Data.csv") %>% 
  select(-c(Case.Number.1, Case.Number.2, original.order, X, X.1))
# leemos el contenido
tiburones %>%
  glimpse()
```

Vamos a trabajar un poco con la limpieza y la normalización de esta base ya que al juntar datos de distintas fuentes la información no es homogénea por lo que es dificil hacer cualquier tipo de análisis.

Analicemos la variable del país (*Country*)

```{r}
# Creamos una lista con los valores de Country para ver si hay algunos problemas
tiburones %>% 
  select(Country) %>% # Seleccionamos la variable del pais
  mutate(Country = as.character(Country)) %>% # Lo convertimos de factor a string
  arrange(Country) %>% # La ordenamos
  distinct() %>% # Nos quedamos con los valores unicos
  as.list() # La convertimos en lista para que sea mas sencilla de ver
```
  
Hay varios problemas, pero veamos dos:

- Hay algunos nombres que no están en mayúscula
- Hay algunos nombres que tienen espacios en blanco a izquierda y derecha

Llevamos los nombres a mayúscula

```{r}
tiburones <- tiburones %>% 
  mutate(pais = str_to_upper(Country))
head(tiburones, 10)
```

Quitamos los espacios en blanco a izquierda y derecha

```{r}
tiburones <- tiburones %>% 
  mutate(pais = str_trim(pais, side = "both"))
tiburones %>% 
  select(pais) %>% # Seleccionamos la variable del pais
  arrange(pais) %>% # La ordenamos
  distinct() %>% # Nos quedamos con los valores unicos
  as.list() # La convertimos en lista para que sea mas sencilla de ver
```

Analizando la variable **Date** de nuestro dataset. Primero llevamos esta variable a un pequeño dataset aparte y llevamos la variable al tipo character para poder manejarla como un string.

```{r}
Date <- tiburones %>% 
  select(Case.Number, Date) %>% # Seleccionamos variables numero caso y fecha
  mutate(Date = as.character(Date)) # Tranformamos la fecha en string
glimpse(Date)
head(Date,10)
```

Vemos que la variable Date viene en muchos casos con la palabra Reported lo cual nos impide que podamos tratar esa expresión como fecha usando las herramientas que vimos en la sección de lubridate.

```{r}
Date <- Date %>% 
  mutate(date_clean1 = str_replace_all(string = Date, pattern =  "Reported ", replacement = ""))
head(Date,10)
```

Vamos ahora a ver el caso de la variable **Time**. Vamos a proceder igual que con la variable Date, creando un pequeño dataset para normalizar esta variable.

```{r}
#traemos la variable que nos interesa
Time <- tiburones %>% 
  select(Time) %>%
  # la llevamos a tipo character para trabajarla como string
  mutate(Time = as.character(Time))
# borro esta entrada porque tiene un dato raro que no nos deja trabajar 
Time[1545,] <- ""
# llevamos todo a minúsculas (con otra función que también hace eso)
Time <- Time %>% 
  mutate(Time = tolower(Time))
Time
```

Nuestro objetivo es llevar las horas a una variable categórica con los valores mañana, tarde y noche. Para eso por un lado vamos a tener que extraer la hora de las variables que la tienen cargada en forma númerica para luego agruparlas en esas tres categorías, y por el otro lado normalizar la forma categórica dada en inglés que actualmente tiene cuatro categorías.

Empecemos trabajando con las entradas que tienen los valores dados en números. Primero vamos a ver que entradas tienen h y vamos a generar una columna con el largo del string.

```{r}
Time <- Time %>% 
  mutate(tiene_h = grepl(pattern = "h",x = Time),
         largo = str_length(Time))
Time
```

Ahora creamos una variable que nos va a decir si se trata de un caso con la hora dada en números. Para detectar estos casos, el string tiene que contener la letra h y tener 5 caracteres.

```{r}
Time = Time %>% 
  mutate(es_hora = case_when(tiene_h == TRUE & largo == 5 ~ "si",
                             tiene_h == FALSE | largo != 5 ~ "no"))
Time
```

Ahora, si se trata de una entrada con el formato de hora, vamos a traer la primera y segunda posición que corresponden a la hora.

```{r}
Time = Time %>% mutate(hora = case_when(es_hora == "si" ~ substr(Time,1,2)),
                       hora = as.numeric(hora))
Time
```

Ahora vamos a llevar los valores numéricos continuos a las variables discretas que mencionamos y vamos a llevar las variables en inglés a las variables en castellano.

```{r}
Time = Time %>% 
  mutate(hora_estandar = case_when(grepl("afternoon",Time) == TRUE ~ "tarde",
                                         grepl("day",Time) == TRUE ~ "tarde",
                                         grepl("night",Time)==TRUE ~ "noche",
                                         grepl("morning",Time)==TRUE~"mañana",
                                         hora > 5 & hora < 12     ~ "mañana",
                                         hora > 11 & hora < 19    ~ "tarde",
                                         hora < 6 | hora > 18     ~ "noche"))
# Reemplazamos los NA por "hora indefinida" 
Time <- Time %>% replace_na(list(hora_estandar="hora indefinida"))
Time
```

Fecha con Lubridate

```{r}
# Seleccionamos algunas variables
tiburones <- tiburones %>% 
  select(Case.Number, Type,Date, pais)
# Hacemos la limpieza de la fecha como vimos más arriba
tiburones <- tiburones %>% 
  mutate(date_clean1 = str_replace_all(string = Date, 
                                       pattern =  "Reported ", 
                                       replacement = ""))
glimpse(tiburones)
```

Transformamos la variable fecha de un string a una fecha

```{r}
tiburones <- tiburones %>% mutate(fecha= dmy(date_clean1))
```

El mensaje indica que no pudo convertir a fecha 887 registros.

Extraemos variables de la fecha
```{r}
tiburones <- tiburones %>% 
  mutate(año = year(fecha), # Obtener el año
         semestre = semester(fecha), # Obtener el semestre
         trimestre = quarter(fecha),# Obtener el trimestre 
         mes = month(fecha,label = TRUE), # Obtener el nombre del mes
         dia = day(fecha),# Obtener el día
         dia_semana = wday(fecha, label = TRUE)) # Obtener el nombre del día
glimpse(tiburones)
```

# [Ggplot2](http://ggplot2.tidyverse.org/reference/)

`ggplot` tiene su sintaxis propia. La idea central es pensar los gráficos como una sucesión de capas, que se construyen una a la vez.    

- El operador __```+```__ nos permite incorporar nuevas capas al gráfico.

- El comando ```ggplot()``` nos permite definir los __datos__ y las __variables__ (x, y, color, forma, etc.). 

- Las sucesivas capas nos permiten definir:
    - Uno o más tipos de gráficos (de columnas, ```geom_col()```, de línea, ```geom_line()```, de puntos,```geom_point()```, boxplot, ```geom_boxplot()```)
    - Títulos ```labs()```
    - Estilo del gráfico ```theme()```
    - Escalas de los ejes ```scale_y_continuous```,```scale_x_discrete``` 
    - División en subconjuntos ```facet_wrap()```,```facet_grid()```

ggplot tiene __muchos__ comandos, y no tiene sentido saberlos de memoria, es siempre útil reutilizar gráficos viejos y tener a mano el [machete](https://www.rstudio.com/wp-content/uploads/2016/11/ggplot2-cheatsheet-2.1.pdf).

```{r}
# usando el dataset iris anterior
library(ggplot2)
library(ggthemes)  # estilos de gráficos
library(ggrepel)   # etiquetas de texto más prolijas que las de ggplot
library(scales)    # tiene la función 'percent()'
ggplot(data = iris, aes(x = Petal.Length, Petal.Width, color = Species)) +
  geom_point(alpha = 0.75) + # agregamos transparencia a los puntos
  labs(title = "Medidas de los pétalos por especie") + 
  theme(legend.position = 'none') + 
  facet_wrap(~ Species)
```

## Capas del Gráfico

Veamos ahora, el "paso a paso" del armado del mismo. 

En primera instancia solo defino los ejes. Y en este caso un color particular para cada Especie.

```{r}
g <- ggplot(data = iris, aes(x = Petal.Length, Petal.Width, color = Species))
g
```

Luego, defino el tipo de gráfico. El *alpha* me permite definir la intensidad/transparencia de los puntos.

```{r}
g <- g +  geom_point(alpha = 0.25)
g
```  
Las siguientes tres capas me permiten respectivamente: 
 
 - Definir el título del gráfico
 - Quitar la leyenda
 - Abrir el gráfico en tres fragmentos, uno para cada especie

```{r} 
g <- g +
  labs(title = "Medidas de los pétalos por especie") +
  theme(legend.position = 'none') +
  facet_wrap(~ Species)
g
```

## Extensiones de [GGplot](http://www.ggplot2-exts.org/gallery/)

La librería GGplot tiene a su vez muchas otras librerías que extienden sus potencialidades. Entre nuestras favoritas están:

- [gganimate](https://gganimate.com/): Para hacer gráficos animados.
- [ggridge](https://cran.r-project.org/web/packages/ggridges/vignettes/introduction.html): Para hacer gráficos de densidad faceteados
- [ggally](https://ggobi.github.io/ggally/): Para hacer varios gráficos juntos.

```{r message=FALSE, warning=FALSE}
library(GGally)
ggpairs(iris,  mapping = aes(color = Species))
```


```{r}
library(ggridges)
ggplot(iris, aes(x = Sepal.Length, y = Species, fill = Species)) + 
  geom_density_ridges()
```

Lo útil de hacer gráficos en R, en lugar de por ejemplo excel, es que podemos hacer uso de más dimensiones, por ejemplo:

- Gráficos que necesitan la información a nivel de microdatos. __puntos__,  __boxplots__, __Kernels__, etc.
- Abrir el mismo gráfico según alguna variable discreta: ```facet_wrap()```
- Parametrizar otras variables, para aumentar la dimensionalidad del gráficos, a través de:
    - [__color__](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf) ```color = ```
    - __relleno__```fill = ```
    - __forma__ ```shape = ```
    - __tamaño__ ```size = ```
    - __transparencia__ ```alpha = ```

Esto permite tener en el plano gráficos de muchas dimensiones de análisis.

Cuando queremos utilizar estos parámetros para representar una variable, los definimos __dentro del aes()__, ```aes(... color = ingresos)```, cuando queremos simplemente mejorar el diseño, se asignan por fuera, o dentro de cada tipo de gráficos, ```geom_col(color = 'green')```.

Para ejemplificar el uso de los gráficos se levanta una base de microdatos de Encuesta Permanente de Hogares (EPH) que publica INDEC.

```{r}
Individual_T120 <- read.table(paste0("../Fuentes/usu_individual_T120.txt"),
                              sep=";", dec=",", header = TRUE, fill = TRUE)
```

### Boxplots

Hacemos un procesamiento simple de la base: Sacamos los ingresos iguales a cero y las no respuestas de nivel educativo (datos faltantes).    

Las variables sexo (*CH04*) y nivel educativo (*NIVEL_ED*) están codificadas como números, y el R las entiende como numéricas. Es importante que las variables sean del tipo que conceptualmente les corresponde (el nivel educativo es una variable categórica, no continua), para que el ggplot pueda graficarlo correctamente, por lo que se las convierte con ```as.factor()```. 

```{r}
ggdata <- Individual_T120 %>%
  filter(P21 > 0, !is.na(NIVEL_ED)) %>% 
  mutate(NIVEL_ED = as.factor(NIVEL_ED),
         CH04     = as.factor(CH04))
ggdata %>%
  head()
```

Si queremos hacer un boxplot del ingreso para cada nivel educativo, asignamos esta variable a _x, group y fill_

```{r}
ggplot(ggdata, aes(x = NIVEL_ED, y = P21, group = NIVEL_ED, fill = NIVEL_ED))+
  geom_boxplot() +
  scale_y_continuous(limits = c(0, 40000)) # definimos escala del eje y
```

Si queremos agregar la dimensión _sexo_, podemos hacer un ```facet_wrap()```

```{r}
ggplot(ggdata, aes(x = NIVEL_ED, y = P21, group = NIVEL_ED, fill = NIVEL_ED))+
  geom_boxplot()+
  scale_y_continuous(limits = c(0, 40000))+
  facet_wrap(~ CH04, labeller = "label_both") # se abre el gráfico en fragmentos segun sexo
```

En este gráfico, el foco de atención sigue puesto en las diferencias de nivel educativo, pero _neutralizamos_ el efecto de la variable sexo.     

Si lo que queremos hacer es poner el foco de atención en las diferencias por sexo, _neutralizamos_ el efecto del nivel educativo, facetiando por nivel educativo.

```{r}
ggplot(ggdata, aes(x = CH04, y = P21, group = CH04, fill = CH04 )) +
  geom_boxplot()+
  scale_y_continuous(limits = c(0, 40000))+
  facet_wrap(~ NIVEL_ED, labeller = "label_both") # se abre el gráfico en fragmentos segun nivel educativo
```

# Ejercicios para practicar

En la carpeta __Fuentes__ se encuentran los archivos __dolar-diario.csv__ y __ipc-mensual.xlsx__. Con ellos, el objetivo es realizar un análisis exploratorio de estas variables de la economía argentina. La base de datos del dolar tiene frecuencia diaria y comienza en Marzo de 2002. La base de datos del IPC tiene frecuencia mensual y comienza en Abril de 2016.

## Ejerecicio 1: Precios y dólar

Para trabajar con el dòlar en una frecuencia mensual vamos a considerar la cotización del primer día hábil de cada mes como la cotización de dicho mes.

Deben poder mostrar los siguientes gráficos y contestar estas preguntas:

a) Gráfico de la evolución del dólar (construir la frecuencia mensual del dólar con el tipo de cambio del primer día hábil del mes).
b) Gráfico de la evolución del IPC General
c) Gráfico de la evolución de los cuatro grupos del IPC
d) ¿Cuál es la media, el desvío estándar, la mediana y el rango del dólar y del IPC General para cada uno de los años?
e) Gráfico de la evolución del dólar y del IPC General para el período de tiempo que tenemos datos de ambas variables
f) Gráfico de la evolución del dólar y de los 4 grupos de IPC para el período de tiempo que tenemos datos de ambas variables

Recomendamos que intenten ir resolviendo los problemas que surjan consultandonos a nosotros, los "machetes" de R y otras páginas pero dejamos una guía de pasos y ayudas 

1. Levantar ambos conjuntos de datos
2. En el dataset del dólar renombramos la variable del tipo de cambio por algo más sencillo
3. Creamos las variables fecha, año, mes y día 
4. Seleccionamos el primer día hábil del mes para obtener la primer cotización del mes (para el dolar)
5. Graficamos la evolución del tipo de cambio
6. Normalizar los datos del IPC. *Pista*: piensen si tienen que usar $spread$ o $gather$
7. Creamos las variables fecha, año y mes
8. Graficamos la evolución del nivel general del IPC
9. Graficamos la evolución de los 4 grupos
10. Realizamos un join de ambos conjuntos de datos. Consideren qué tipo de join tienen que usar 
11. Obtenemos las estadisticas de resumen de la pregunta d)
11. Graficamos la evoluciòn del dólar y del nivel general del IPC (tener en cuenta el rango de las variables)
12. Graficamos la evoluciòn del dólar y de los grupos del IPC

## Ejercicio 2: EPH (OPCIONAL)

El Objetivo de estos ejercicios es practicar el uso del $tidyverse$ para la manipulación de los datos, y $ggplot$ para graficar la información. En las consignas, se propone de manera general qué variables se quiere observar. Ustedes deberán levantar y procesar los datos de la Encuesta Permanente de Hogares, y gráficarlos como consideren que mejor se aprecia la relación entre las variables.     

Una __ayuda__ es utilizar el [diseño de registro](../Fuentes/EPH_registro_2_trim_2016.pdf) para codificar las variables

  
__ejercicios__

- Graficar la distribución del ingreso por ocupación principal (p21) según categoría ocupacional (CAT_OCUP). (opcional: utilizar la librería [ggridges](https://cran.r-project.org/web/packages/ggridges/vignettes/introduction.html))

- Incorporar en el gráfico anterior la condición de precariedad laboral (PP07H).

- Quedarse sólo con los asalariados (CAT_OCUP = 3), y graficar la relación entre ingreso por ocupación principal(p21), precariedad laboral (PP07H) y tamaño del establecimiento(PP04C99).

- Quedarse con los Cuentapropistas y asalariados (CAT_OCUP = 2 y 3) y comparar, según la condición de precariedad laboral (PP07H) la distribución del ingreso según sexo (CH04)

- Incorporar en el gráfico anterior el tamaño del establecimiento(PP04C99)


__yapa:__ Si quisieramos modelar la probabilidad de un evento podemos usar una regresión logísitca (en ggplot ```stat_smooth(method="glm", method.args=list(family="binomial")```).     
Utilicen este modelo para hacer un gráfico que eche luz sobre el siguiente fenómeno: 

- ¿Cómo se distribuye la probabilidad de querer trabajar más horas (PP03G) según el total de horas trabajadas por semana (PP3E_TOT)? ¿Es diferente el modelo según sexo(CH04)?



