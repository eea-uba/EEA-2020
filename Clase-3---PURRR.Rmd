---
title: "Tidyverse: PURRR"
author: "Juan Barriola y Sofía Perini"
date: "17 de Octubre de 2020"
output:
  html_notebook:
    theme: spacelab
    toc: yes
    toc_float: yes
    df_print: paged
---

Librerias que se utilizan en esta clase:

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(openxlsx)
library(ggthemes)
library(fs)
```

Basado en los [tutoriales de PURRR](https://jennybc.github.io/purrr-tutorial/index.html) de Jenny Bryan y el capítulo [Iteration](https://r4ds.had.co.nz/iteration.html) del libro R for Data Science de Garrett Grolemund y Hadley Wickham

# PURRR

[PURRR](https://purrr.tidyverse.org/) es una librería en R que contiene funciones y métodos de programación funcional dentro del entorno de tidyverse.

## MAP

MAP es una **función** para aplicar una función a cada elemento de una estructura de datos como una lista o vector. El funcionamiento de map consiste en recorrer ("loopear") la estructura aplicando la función a cada elemento y guardando los resultados. De esta manera podemos reemplazar los loops por una forma más legible y clara de código.

La función `map` toma como argumentos:
 
 * .x: un vector o lista input
 
 * .f: una función para aplicar
 
map(VECTOR_O_LIST_INPUT, FUNCTION_A_APLICAR, OTROS_OPCIONALES)

Veamos un ejemplo con un vector numérico

```{r}
# Aplicamos la función log10 sobre un vector
map(.x = c(10,100,1000), .f=log10)
```

### Map: tipos específicos

Veamos que el resultado de map es una lista. Si sabemos cuál es el tipo de dato de nuestros resultados podemos usar variaciones de map que explicitan el tipo de dato y devuelven los resultados en un vector. Algunas de ellas son:

  * map_lgl() devuelve un vector de booleanos
 
  * map_dbl() devuelve un vector numérico

  * map_chr() devuelve un vector de strings 

Volvamos a ver nuestro ejemplo usando `map_dbl`

```{r}
map_dbl(.x = c(10,100,1000), .f=log10)
```

### Map: funciones

Se pueden aplicar funciones de R base o de las librerías como así también funciones definidas por el usuario. Muchas veces no es necesario definir una función de antemano, sino que podemos usar **funciones anónimas** o **funciones lambda**.

#### Funciones anónimas

La función se define en una única linea. 

**Ejemplo numérico**

Por ejemplo, calculamos una función cuadrática para un vector numérico que va del 1 al 10.

```{r}
# Calculamos una función cuadrática para el vector
map_dbl(.x = c(1:10), .f = function(x) x^2+1)
```

**Ejemplo con strings**

A partir de un vector de strings queremos contar la cantidad de letras "A" en cada elemento. Para eso combinamos las funciones `str_to_upper` y `str_count`.

```{r}
map_dbl(.x = c("papas FRITAS", "batatas HERVIDAS", "boniato AL HORNO"),
        # conviertimos todas a mayúsculas y contamos la cantidad de "A"
        .f = function(x) str_count(string = str_to_upper(x), pattern = "A"))
```

#### Funciones lambda

Son una forma aún más concisa de declarar funciones, aunque pueden ser más limitadas. Las variables se declaran como .x

```{r}
# Calculamos otra función cuadrática para el vector
map_dbl(.x = c(1:10), .f =  ~.x^2 - .x)
```

### Map: Múltiples argumentos
 
Usamos `map2` cuando queremos aplicar una función sobre dos listas o vectores:

- map2(.x, .y, .f, ...)
- map2(INPUT_UNO, INPUT_DOS, FUNCTION_A_APLICAR, OTROS_OPCIONALES)

**Ejemplo numérico**

Veamos un ejemplo para generar observaciones de distribuciones normales a partir de los vectores de mu y sigma (este es el ejemplo del libro *R for Data Science*).

La funcion `rnorm` sirve para generar muestras aleatorias de distribución normal con media igual a mu y desviación estándar igual a sigma, donde n indica la cantidad de observaciones a generar. 

```{r}
# Vector de mu = medias
mu = c(0, 3, -5, 2.1)
# Vector de sigma = desvíos estándar
sigma = c(1, 0.5, 5, 0.01)
# Generamos 10 observaciones a partir de nuestros vectores
map2(.x = mu, .y = sigma, .f= rnorm, n = 10)
```

**Ejemplo con strings**

Ahora veamos con un ejemplo para crear una lista de compras.

```{r}
# Vectores
kilos = c(10, 1, 6, 8, 3)
verduras =  c("papa", "batata", "zapallo", "boniato", "zanahoria")
# concatenamos las palabras (con nombres en mayúscula) y valores
map2_chr(.x = verduras, .y =kilos, .f = function(x,y) str_c(str_to_title(x),y, sep=": "))
```
  
  
Usamos `pmap` cuando queremos aplicar una función sobre una lista de argumentos:

- pmap(.l, .f, ...)
- pmap(VECTOR_O_LIST_DE_INPUTS, FUNCTION_A_APLICAR, OTROS_OPCIONALES)

Volvamos al ejemplo para generar observaciones de distribuciones normales a partir de los vectores de mu y sigma, pero ahora incorporamos la cantidad de observaciones como un argumento adicional (este ejemplo también es del libro *R for Data Science*).

```{r}
# Vector de mu
mu = c(0, 3, -5, 2.1)
# Vector de sigma
sigma = c(1, 0.5, 5, 0.01)
# Vector de cantidad de observaciones 
n = c(1:4)
# Lista de argumentos
argumentos <- list(n, mu, sigma)
# Generamos las observaciones a partir de nuestra lista de parámetros
pmap(.l = argumentos, .f = rnorm)
```

## PURRR: Dataframes y modelos

### Dataframes

Las funciones de PURRR se pueden utilizar para realizar operaciones sobre dataframes. La sintaxis que vamos a utilizar es:

`map(dataframe, función)`

De esta manera vamos a estar aplicando la función sobre todas las columnas del dataframe. Veamos un ejemplo usando nuestra encuesta de sueldos del sector IT limpia. 

```{r}
# cargamos el dataset
encuesta_sueldos_limpia = read_csv("../Fuentes/encuesta_ds_final.csv")
encuesta_sueldos_limpia <- encuesta_sueldos_limpia %>%
  # creamos variable perfil BI/DA vs DS/DI
  mutate(perfil = case_when(trabajo_de == "BI Analyst / Data Analyst" ~ "BI/DA", TRUE ~ "DS/DE"))
```

Comencemos analizando la cantidad de valores distintos para cada columna. Para ello usamos la función `n_distinct`.

```{r}
map(encuesta_sueldos_limpia, n_distinct)
```

Usando la función `str()` se puede consultar de forma compacta la estructura interna de un objeto R. Es especialmente adecuado para mostrar de forma compacta el contenido (abreviado) de listas. 

```{r}
map(encuesta_sueldos_limpia, n_distinct) %>%
  str() # Agregamos str para que la salida luzca mejor
```

Ahora calculamos el promedio sobre las columnas numéricas.

```{r}
encuesta_sueldos_limpia %>% 
  select_if(is.numeric) %>% 
  map(mean) %>% 
  str()
```

Calculamos la mediana sobre las columnas numéricas. Sabiendo que el resultado de la función es un número podemos usar directamente la función `map_dbl`.

```{r}
# usando map_dbl 
encuesta_sueldos_limpia %>% 
  select_if(is.numeric) %>% 
  map_dbl(median)
```

Recordemos que esta función devuelve un vector numérico no una lista como en el caso anterior, por eso no usamos la función `str()` para ver el resultado en forma compacta.

### Modelos

Podemos usar la función map para calcular distintos modelos modelos. Por ejemplo, calculemos un modelo distinto según el perfil (DA y DS).

```{r}
modelos_por_perfil = encuesta_sueldos_limpia %>% 
                        # separamos el dataset según perfil
                        split(.$perfil) %>% 
                        # creamos un modelo para cada perfil  
                        map(~lm(salario_neto ~ edad, data = .))
```

El resultado de esto es una lista con los dos modelos. Analicemos los elementos de cada uno utilizando la función tidy() de la librería broom. 

```{r}
modelos_por_perfil %>% 
  map(broom::tidy)
```
Evaluemos ahora la capacidad explicativa de los modelos. Para ello, comparamos el $R^2$ de cada uno (en este caso como son modelos simples podemos utilizar esta métrica). 

```{r}
modelos_por_perfil %>% 
  map(broom::glance) %>% 
  map_dbl("r.squared")
```

Mientras el modelo de edad para los perfiles BI/DA logra explicar el 15.6% de la variabilidad del fenómeno, el modelo de edad para los DS/DE logra captar un porcentaje menor de la variabilidad (12,9%). 

## Ejemplo: Iterando en la EPH

Lo primero que necesitamos es definir un vector o lista sobre el que iterar. 

Por ejemplo, podemos armar un vector con los path a las bases individuales, con el comando `fs::dir_ls`. Se le especifica el __path__ donde buscar los archivos y en este caso una expresion regular __regexp__ para que devuelva aquellos archivos que coinciden con la misma. 

```{r}
# Buscamos en el path aquellos aquellos archivos que matchean a la expresion regular
bases_individuales_path <- dir_ls(path = '../Fuentes/', regexp = 'usu_individual_T')
bases_individuales_path
```

Luego, como en la función que usamos para leer las bases definimos muchos parámetros, nos podemos armar una función _wrapper_ que sólo necesite un parámetro y simplifique la escritura del map.

```{r message=FALSE, warning=FALSE}
# Leer la base de EPH tomando como argumento el file_path
leer_base_eph <- function(path) {
  # Lectura de archivos
  read.table(path, sep = ";", dec = ",", header = TRUE, fill = TRUE) %>%
  # Seleccionamos variables de interés
  select(ANO4, TRIMESTRE, REGION, P21, CH04, CH06)
}
```

Creamos una tabla que incluya los paths de cada base en una columna y los dataframes anidados correspondientes a cada base en otra. 

```{r message=FALSE, warning=FALSE}
# creamos la tabla de bases
bases_df <- tibble(bases_individuales_path) %>%
  mutate(base = map(.x = bases_individuales_path, .f = leer_base_eph))
bases_df
```

El resultado es un dataframe donde la columna __base__ tiene en cada fila el dataframe con la base de la EPH de ese período. Esto es lo que llamamos un _nested DF_ o dataframe anidado.

Si queremos abrir ("desanidar") estos dataframes anidados usamos el comando `unnest()`.

```{r message=FALSE, warning=FALSE}
# Desanidamos el dataframe
bases_df <- bases_df %>% unnest()
bases_df
```
¿Qué pasa si los dataframes que tenemos anidados no tienen la misma cantidad de columnas?

Esto mismo lo podemos usar para fragmentar el dataset por alguna variable, con la funcion `group_by()`

```{r}
bases_df %>% 
  # Agrupar por género
  group_by(CH04) %>% 
  # Anidar
  nest()
```
> ¿ De qué sirve todo esto?

No todo en la vida es un Dataframe. Hay estucturas de datos que no se pueden normalizar a filas y columnas. En esos casos recurríamos tradicionalmente a los loops. Con MAP podemos tener los elementos agrupados en un sólo objeto y aún conservar sus formas diferentes.

## Ejemplo. Regresión lineal simple

Planteamos un modelo para explicar el ingreso (P21 en nuestra base) en función de la edad (CH06 en la base). 

$$
Ingreso = \beta_0 + \beta_1*Edad
$$
Calculamos una regresion lineal sobre el dataset que contiene todas las bases de EPH. 

```{r}
lmfit <- lm(P21~CH06, data = bases_df)
# Resumen del modelo
broom::tidy(lmfit)
```

(al final de la clase podemos charlar sobre los resultados)

De forma Tidy, la librería `broom` nos da los resultados sobre los coeficientes en un DF.

```{r}
broom::tidy(lmfit)
```
 
Si lo queremos hacer por género, veamos cómo podemos hacerlo usando MAP. 
 
## Usando MAP

Primero armamos una funcion que simplifica el código y nos devuelve la información de los coeficientes del modelo lineal calculado sobre el dataframe __base__. 

```{r}
fun <- function(base, grupo){broom::tidy(lm(P21~CH06, data = base))}
```

Calculamos la regresión lineal para cada grupo. En este caso elegimos género, pero podría haber sido por región también u otra variable de interés. 

```{r}
bases_df_lm <- bases_df %>% 
  # Agrupamos por género
  group_by(CH04) %>%
  # Anidamos
  nest() %>% 
  # Creamos una variable que contenga el dataframe resultante de aplicar la función que creamos antes
  mutate(lm = map(data, fun))
bases_df_lm
```
Obtenemos como resultado un data frame con los dos modelos anidados. Veamos los resultados del modelo, desanidando la variable lm. 

```{r}
# Desanidamos por la variable lm
bases_df_lm %>% 
  unnest(lm)
```

#### me quedé acá - falta actualizar WALK #### 

## Walk

Las funciones `Walk` tienen la misma forma que los `map`, pero se usan cuando lo que queremos iterar no genera una salida, sino que nos interesan los efectos secundarios que generan.

```{r}
map2(.x = ABC_123$Letras,.y = ABC_123$Num,.f = funcion_prueba)[1:3]
```

```{r}
walk2(.x = ABC_123$Letras,.y = ABC_123$Num,.f = funcion_prueba)
```

Notemos que `walk2` no devolvió un resultado

```{r}
# funcion para imprimir
imprimir_salida <- function(x,y){
  print(funcion_prueba(x,y))
}

# Map
map2(ABC_123$Letras,ABC_123$Num,imprimir_salida)
```

```{r}
# Walk
walk2(ABC_123$Letras,ABC_123$Num,imprimir_salida)

```

Eso que vemos es el efecto secundario dentro de la función (imprimir)

## Discusión.

> ¿Cuándo usar estas herramientas?

En el curso hemos visto diferentes técnicas para manipulación de datos. En particular, la librería dplyr nos permitía fácilmente modificar y crear nuevas variables, agrupando. ¿Cuando usamos `dplyr` y cuando usamos `purrr`?

- Si trabajamos sobre un DF simple, sin variables anidadas (lo que conocíamos hasta hoy) podemos usar `dplyr`

- Si queremos trabajar con DF anidados, con cosas que no son DF, o si el resultado de la operación que vamos a realizar a nivel archivo es algo distinto a un valor único, nos conviene usar `map` y `purrr`.

- Las funciones `walk` son útiles por ejemplo para escribir archivos en disco de forma iterativa. Algo que no genera una salida. 

